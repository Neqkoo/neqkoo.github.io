<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bomberman Enhanced</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; font-family: sans-serif; background: #1c1c1c; color: #fff; display: flex; }
    #ui { width: 260px; padding: 20px; background: #2b2b2b; }
    #ui h1 { font-size: 20px; margin: 0 0 10px; }
    #ui select, #ui button { width: 100%; margin: 10px 0; font-size: 16px; padding: 8px; }
    #ui p { font-size: 12px; color: #ccc; }
    canvas { border: 4px solid #444; background: #333; margin: 20px; image-rendering: pixelated; }
    .pill { display: inline-block; margin: 4px 0; padding: 6px 10px; border-radius: 5px; font-size: 13px; color: #111; }
    .p1 { background: #ff9090; } .p2 { background: #90ffc0; } .p3 { background: #90c0ff; } .p4 { background: #ffe090; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>Bomberman+</h1>
    <label for="humanCount">Human Players:</label>
    <select id="humanCount">
      <option value="1">1</option>
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
    </select>
    <button id="startBtn">Start Game</button>
    <p><span class="pill p1">P1: WASD + Space</span></p>
    <p><span class="pill p2">P2: Arrows + /</span></p>
    <p><span class="pill p3">P3: IJKL + O</span></p>
    <p><span class="pill p4">P4: TFGH + R</span></p>
    <p>Items: <strong>+B</strong> Bomb, <strong>+R</strong> Range, <strong>+S</strong> Speed</p>
    <p>Last alive wins</p>
    <button id="restartBtn">Back to Menu</button>
    <p id="status">Awaiting input...</p>
  </div>
  <canvas id="game" width="816" height="624"></canvas>
  <script>
    const TILE = 48, ROWS = 13, COLS = 17;
    const TILE_WALL = 1, TILE_BLOCK = 2;
    const ITEM_EXTRA = 1, ITEM_RANGE = 2, ITEM_SPEED = 3;
    const COLORS = { wall:'#444', block:'#854', floor:'#444c', bomb:'#000', flame:'#fc6' };
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
    const humanCountSel = document.getElementById('humanCount'), status = document.getElementById('status');
    const keysets = [
      {up:'w',down:'s',left:'a',right:'d',bomb:' '},
      {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight',bomb:'/'},
      {up:'i',down:'k',left:'j',right:'l',bomb:'o'},
      {up:'t',down:'g',left:'f',right:'h',bomb:'r'}
    ];
    let keys={}, map=[], items=[], bombs=[], flames=[], players=[], state='menu', humanCount=2, tick=0;
    const rand = n => Math.floor(Math.random()*n), chance = p => Math.random() < p;
    document.addEventListener('keydown', e=>{ keys[e.key]=true; if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter','/'].includes(e.key)) e.preventDefault(); });
    document.addEventListener('keyup', e=>{ keys[e.key]=false; });
    document.getElementById('startBtn').onclick = ()=>{ humanCount=+humanCountSel.value; startGame(); };
    document.getElementById('restartBtn').onclick = ()=>{ state='menu'; status.textContent='Awaiting input...'; };

    function startGame() {
      state = 'playing'; status.textContent='Playing...'; tick=0; map = [], bombs=[], flames=[], items=[];
      for (let r=0;r<ROWS;r++) {
        let row=[]; for (let c=0;c<COLS;c++) {
          if (r===0||c===0||r===ROWS-1||c===COLS-1 || (r%2===0 && c%2===0)) row.push(TILE_WALL);
          else row.push(chance(0.75)?TILE_BLOCK:0);
        } map.push(row);
      }
      let spawns=[[1,1],[ROWS-2,COLS-2],[1,COLS-2],[ROWS-2,1]];
      for (let [r,c] of spawns) for (let dr=0;dr<=1;dr++) for (let dc=0;dc<=1;dc++) map[r+dr][c+dc]=0;
      players = [];
      for (let i=0;i<4;i++) {
        let [r,c]=spawns[i];
        players.push({id:i, r, c, alive:true, human:i<humanCount, bombMax:1, bombCount:0, range:1, speed:1, moveCD:0, aiDir:null, aiTick:0});
      }
    }

    function loop() {
      requestAnimationFrame(loop); if (state!=='playing') return;
      tick++; ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let b of bombs) { b.t--; if (b.t<=0) explode(b); }
      bombs = bombs.filter(b=>b.t>0);
      for (let f of flames) f.t--;
      flames = flames.filter(f=>f.t>0);
      for (let p of players) if (p.alive) {
        if (flames.some(f=>f.r===p.r&&f.c===p.c)) p.alive=false;
      }
      for (let p of players) if (p.alive) {
        if (p.human) handleInput(p); else handleAI(p);
      }
      for (let it of items) {
        for (let p of players) if (p.alive && p.r===it.r && p.c===it.c) {
          if (it.t===ITEM_EXTRA) p.bombMax++;
          if (it.t===ITEM_RANGE) p.range++;
          if (it.t===ITEM_SPEED) p.speed+=0.5;
          it.dead=true;
        }
      }
      items = items.filter(i=>!i.dead);
      draw();
      let alive = players.filter(p=>p.alive);
      if (alive.length<=1) {
        state='over';
        status.textContent = alive.length ? `Winner: P${alive[0].id+1}` : 'Draw!';
      }
    }

    function handleInput(p) {
      const k=keysets[p.id]; const s=12/p.speed; if (p.moveCD>0) p.moveCD--;
      let moved=false,tr=p.r,tc=p.c;
      if (p.moveCD<=0) {
        if (keys[k.up]) tr--;
        else if (keys[k.down]) tr++;
        else if (keys[k.left]) tc--;
        else if (keys[k.right]) tc++;
        if (canMove(tr,tc)) { p.r=tr;p.c=tc;p.moveCD=s; }
      }
      if (keys[k.bomb] && !p.bombLock) {
        dropBomb(p); p.bombLock=true;
      } else if (!keys[k.bomb]) p.bombLock=false;
    }

    function handleAI(p) {
      const s=12/p.speed; if (p.moveCD>0) p.moveCD--;
      if (--p.aiTick<=0) {
        p.aiTick=20+rand(40);
        let targets = players.filter(x=>x.human && x.alive);
        if (targets.length) {
          let nearest = targets.reduce((a,b)=>dist(p,b)<dist(p,a)?b:a);
          if (dist(p,nearest)<=6) {
            if (Math.abs(nearest.r-p.r)>Math.abs(nearest.c-p.c)) p.aiDir = (nearest.r<p.r)?'up':'down';
            else p.aiDir = (nearest.c<p.c)?'left':'right';
          }
        }
      }
      let dir = p.aiDir || ['up','down','left','right'][rand(4)];
      let [tr,tc]=[p.r,p.c]; if (dir==='up') tr--; if (dir==='down') tr++; if (dir==='left') tc--; if (dir==='right') tc++;
      if (p.moveCD<=0 && canMove(tr,tc) && !flames.some(f=>f.r===tr&&f.c===tc)) { p.r=tr;p.c=tc;p.moveCD=s; }
      if (bombs.every(b=>!(b.r===p.r&&b.c===p.c)) && chance(0.01)) dropBomb(p);
    }

    function canMove(r,c) {
      if (r<0||r>=ROWS||c<0||c>=COLS) return false;
      if (map[r][c]!==0) return false;
      if (bombs.some(b=>b.r===r&&b.c===c)) return false;
      return true;
    }

    function dropBomb(p) {
      if (p.bombCount>=p.bombMax) return;
      if (bombs.some(b=>b.r===p.r&&b.c===p.c)) return;
      bombs.push({r:p.r,c:p.c,t:80,p,range:p.range}); p.bombCount++;
    }

    function explode(b) {
      b.p.bombCount--; flames.push({r:b.r,c:b.c,t:20});
      for (let [dr,dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
        for (let i=1;i<=b.range;i++) {
          let nr=b.r+dr*i,nc=b.c+dc*i;
          if (nr<0||nr>=ROWS||nc<0||nc>=COLS) break;
          if (map[nr][nc]===TILE_WALL) break;
          flames.push({r:nr,c:nc,t:20});
          if (map[nr][nc]===TILE_BLOCK) {
            map[nr][nc]=0;
            if (chance(0.3)) {
              items.push({r:nr,c:nc,t:rand(3)+1});
            }
            break;
          }
          let other = bombs.find(x=>x.r===nr&&x.c===nc);
          if (other) { other.t=1; break; }
        }
      }
    }

    function draw() {
      for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
        ctx.fillStyle=map[r][c]===TILE_WALL?COLORS.wall:map[r][c]===TILE_BLOCK?COLORS.block:COLORS.floor;
        ctx.fillRect(c*TILE,r*TILE,TILE,TILE);
      }
      for (let it of items) {
        ctx.fillStyle = it.t===ITEM_EXTRA?'#0ff':it.t===ITEM_RANGE?'#f0f':'#ff0';
        ctx.fillRect(it.c*TILE+12,it.r*TILE+12,24,24);
      }
      for (let b of bombs) {
        ctx.fillStyle=COLORS.bomb;
        ctx.beginPath(); ctx.arc(b.c*TILE+24,b.r*TILE+24,16,0,Math.PI*2); ctx.fill();
      }
      for (let f of flames) {
        ctx.fillStyle=COLORS.flame;
        ctx.fillRect(f.c*TILE+4,f.r*TILE+4,40,40);
      }
      for (let p of players) if (p.alive) {
        ctx.fillStyle=['#f66','#6f6','#66f','#ff6'][p.id];
        ctx.beginPath(); ctx.arc(p.c*TILE+24,p.r*TILE+24,18,0,Math.PI*2); ctx.fill();
      }
    }

    function dist(a,b){ return Math.abs(a.r-b.r)+Math.abs(a.c-b.c); }

    loop();
  </script>
</body>
</html>
