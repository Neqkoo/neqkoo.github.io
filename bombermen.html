<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>4 Player Bomberman</title>
  <style>
    body {
      background: #222;
      color: white;
      font-family: sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 4px solid #fff;
      margin-top: 10px;
      background: #111;
    }
    .instructions {
      font-size: 14px;
      max-width: 800px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>üî• 4-Player Bomberman</h1>
  <div class="instructions">
    <p><strong>Player 1:</strong> W A S D + F (bomb)</p>
    <p><strong>Player 2:</strong> ‚Üë ‚Üê ‚Üì ‚Üí + / (bomb)</p>
    <p><strong>Player 3:</strong> T F G H + R (bomb)</p>
    <p><strong>Player 4:</strong> I J K L + U (bomb)</p>
    <p><strong>Objective:</strong> Last player standing wins. Collect items to boost abilities.</p>
  </div>
  <canvas id="game" width="640" height="480"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const TILE = 32;
    const MAP_COLS = 20;
    const MAP_ROWS = 15;

    const EMPTY = 0, WALL = 1, BLOCK = 2, BOMB = 3, EXPLOSION = 4, ITEM = 5;

    const ITEM_TYPES = ['speed', 'bombUp', 'rangeUp', 'ghost', 'kick', 'remote', 'shield', 'swap'];

    const COLORS = ['red', 'blue', 'green', 'orange'];

    let map = [];

    const players = [];
    const bombs = [];
    const explosions = [];
    const items = [];

    const keys = {};

    function createMap() {
      map = Array(MAP_ROWS).fill().map(() => Array(MAP_COLS).fill(BLOCK));
      for (let y = 0; y < MAP_ROWS; y++) {
        for (let x = 0; x < MAP_COLS; x++) {
          if (x === 0 || y === 0 || x === MAP_COLS - 1 || y === MAP_ROWS - 1 || (x % 2 === 0 && y % 2 === 0)) {
            map[y][x] = WALL;
          } else if (Math.random() < 0.2) {
            map[y][x] = EMPTY;
          }
        }
      }
    }

    function addPlayer(x, y, controls, color) {
      players.push({
        x, y, color,
        bombs: 1,
        range: 2,
        speed: 2,
        alive: true,
        cooldown: 0,
        controls,
        items: []
      });
    }

    function placeBomb(p) {
      if (p.cooldown > 0 || bombs.filter(b => b.owner === p).length >= p.bombs) return;
      if (map[p.y][p.x] === BOMB) return;
      bombs.push({ x: p.x, y: p.y, timer: 120, range: p.range, owner: p });
      map[p.y][p.x] = BOMB;
      p.cooldown = 15;
    }

    function explodeBomb(b) {
      map[b.y][b.x] = EXPLOSION;
      explosions.push({ x: b.x, y: b.y, timer: 30 });
      const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
      for (let [dx, dy] of dirs) {
        for (let i = 1; i <= b.range; i++) {
          let nx = b.x + dx*i, ny = b.y + dy*i;
          if (map[ny]?.[nx] === WALL) break;
          if (map[ny][nx] === BLOCK) {
            if (Math.random() < 0.3) {
              items.push({ x: nx, y: ny, type: ITEM_TYPES[Math.floor(Math.random()*ITEM_TYPES.length)] });
              map[ny][nx] = ITEM;
            } else {
              map[ny][nx] = EXPLOSION;
            }
            explosions.push({ x: nx, y: ny, timer: 30 });
            break;
          }
          if (map[ny][nx] === BOMB) {
            let chain = bombs.find(bm => bm.x === nx && bm.y === ny);
            if (chain) chain.timer = 0;
            break;
          }
          map[ny][nx] = EXPLOSION;
          explosions.push({ x: nx, y: ny, timer: 30 });
        }
      }
    }

    function update() {
      players.forEach(p => {
        if (!p.alive) return;
        p.cooldown = Math.max(0, p.cooldown - 1);
        let [up, left, down, right, bomb] = p.controls.map(c => keys[c]);
        let dx = 0, dy = 0;
        if (up) dy = -1;
        else if (down) dy = 1;
        else if (left) dx = -1;
        else if (right) dx = 1;

        if (dx || dy) {
          let nx = p.x + dx, ny = p.y + dy;
          if (map[ny]?.[nx] === EMPTY || map[ny][nx] === ITEM) {
            p.x = nx; p.y = ny;
          }
        }
        if (bomb) placeBomb(p);
      });

      bombs.forEach(b => b.timer--);
      bombs.filter(b => b.timer <= 0).forEach(b => explodeBomb(b));
      bombs.filter(b => b.timer <= 0).forEach(b => {
        if (map[b.y][b.x] === BOMB) map[b.y][b.x] = EXPLOSION;
      });
      bombs = bombs.filter(b => b.timer > 0);

      explosions.forEach(e => e.timer--);
      explosions.forEach(e => {
        players.forEach(p => {
          if (p.x === e.x && p.y === e.y && p.alive) {
            p.alive = false;
          }
        });
      });
      explosions = explosions.filter(e => e.timer > 0);

      items.forEach(item => {
        players.forEach(p => {
          if (p.x === item.x && p.y === item.y && p.alive) {
            map[item.y][item.x] = EMPTY;
            p.items.push(item.type);
            if (item.type === 'bombUp') p.bombs++;
            if (item.type === 'rangeUp') p.range++;
            if (item.type === 'speed') p.speed++;
          }
        });
      });
      items.filter(i => map[i.y][i.x] !== ITEM);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < MAP_ROWS; y++) {
        for (let x = 0; x < MAP_COLS; x++) {
          if (map[y][x] === WALL) {
            ctx.fillStyle = '#666';
            ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          } else if (map[y][x] === BLOCK) {
            ctx.fillStyle = '#999';
            ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          } else if (map[y][x] === BOMB) {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, TILE/3, 0, Math.PI*2);
            ctx.fill();
          } else if (map[y][x] === EXPLOSION) {
            ctx.fillStyle = 'orange';
            ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
          } else if (map[y][x] === ITEM) {
            ctx.fillStyle = 'lime';
            ctx.beginPath();
            ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, TILE/4, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }

      players.forEach(p => {
        if (!p.alive) return;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x*TILE+4, p.y*TILE+4, TILE-8, TILE-8);
      });
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function init() {
      createMap();
      addPlayer(1, 1, ['w','a','s','d','f'], 'red');
      addPlayer(MAP_COLS-2, 1, ['ArrowUp','ArrowLeft','ArrowDown','ArrowRight','/'], 'blue');
      addPlayer(1, MAP_ROWS-2, ['t','f','g','h','r'], 'green');
      addPlayer(MAP_COLS-2, MAP_ROWS-2, ['i','j','k','l','u'], 'orange');
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener("keydown", e => keys[e.key] = true);
    window.addEventListener("keyup", e => keys[e.key] = false);

    init();
  </script>
</body>
</html>
